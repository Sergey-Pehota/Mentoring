/*
 План
    - Описание концепции Lifecycle у ViewController
    - Разбор ключевых слов super, override, private
    - Отличать ДЕКЛАРАЦИЮ (объявление) чего-либо и СОЗДАНИЕ/ВЫЗОВ
 
 Ниже представлена чуть более наглядная демонстрация того, что объяснял про жизненный цикл
 вью контроллера. Будем имитировать то, что происходит в реальном проекте.
 
 ВАЖНОЕ:
 
 * Запомни, комментарий всегда относится к тому, что написано ниже (класс, метод или что угодно)

 ----------------
 КЛАСС
 
 * Класс мы можем декларировать (описать, объявить), а можем создать (говорят "создать объект класса)",
 т.е. выделить память под него, и он становится реальным объектом и занимает какую-то память в компьютере/iPhone.
 
 Декларация делается с фигурными скобками и ключевым словом class, например class Person { ... },
 class ViewController { ... }. Выглядет так
 
 class Person {
    ...
 }
 
 Создание же осуществляется с круглыми скобками без слова 'class', например Person(), ViewController().
 Выглядет так
 
 let person = Person()
 
 В примере выше мы говорим: "Товарищ компьютер, выдели-ка мне память под объект
 класса 'Person' (с большой буквы!), и помести этот объект в эту память, и добавь ссылку
 с именем 'person' (с маленькой буквы!), чтобы мы имели доступ к этому объекту". Слово 'person' - это
 как ярлык на рабочем столе, просто ссылка на объект в памяти.
 
 Можно и просто написать:
 
 Person()
 
 Система тебя поймёт. Точно так же создашь объект, но без ссылки 'person'. А значит нам никак не получить
 доступ к этому объекту, потому что нет ссылки. Но в отличии от примера с ярлыком на рабочем столе,
 если на объект в памяти нет ссылки, он автоматически уничтожается (удаляется из памяти), т.к.
 система считает, что он тебе не нужен. А ярлык удалил, программа останется.
 
 Пока мы не создали объект, это просто описанная модель в Xcode, её нет в памяти! Её ещё не существует!
 Аналогия: написать закон - декларация, применить на практике - создание объекта и его использование.

 ----------------
 ФУНКЦИЯ (МЕТОД)
 
 * Функцию или метод мы можем декларировать, а можем вызвать (про память аналогично, как с классом).
 Декларируется с фигурными скобками и словом func, но присутствуют и круглые скобки (такой синтаксис), например
 func activity() { ... }, func viewDidLoad() { ... }.
 
 Выглядет так
 
 func viewDidLoad() {
    ...
 }
 
 Вызов же осуществялется ТОЛЬКО с круглыми скобками и без слова func, например activity(), viewDidLoad().
 */


// import UIKit <-- комментируем! Так как разбираемся с концепцией. Нам не нужен доступ к библиотеке UIKit

// Декларируем класс UIViewController - наш БАЗОВЫЙ КЛАСС (привет Наследование)
class UIViewController {
    
    // Этот метод мы НЕ разбирали, обычно его не спрашивают на собесе.
    // В реальном классе от Apple тут происходит загрузка View. Какие-то технические детали
    // Декларируем метод loadView
    func loadView() {
        // Вызываем метод print
        print("SYSTEM -> loadView in UIViewController")
        
        // Чтобы загрузить View и подготовить к отображению, надо выполнить какие-то технические детали
        // Вызываем метод doAnyTechnicalStuff
        doAnyTechnicalStuff()
    }
    
    // Этот метод разбирали
    // В реальном классе от Apple он вызывается, когда View загрузилось и готово к отображению
    // Декларируем метод viewDidLoad
    func viewDidLoad() {
        // Вызываем метод print
        print("SYSTEM -> viewDidLoad in UIViewController")
    }
    
    // Псевдометод, просто придумал наобум для описания самой концепции. В реальности его нет.
    // Он приватный, о чём говорит ключевое слово 'private'. Только класс UIViewController имеет к нему доступ.
    // Декларируем метод doAnyTechnicalStuff
    private func doAnyTechnicalStuff() {
        // Вызываем метод print
        print("SYSTEM -> doAnyTechnicalStuff in UIViewController")
        
        // После того, как выполнились эти технические детали и View загрузилось, вызывается viewDidLoad()
        // Вызов метода viewDidLoad
        viewDidLoad()
    }
}

// Теперь к нашему первому экрану

// Декларируем класс FirstViewController - наш ДОЧЕРНИЙ КЛАСС, наследник UIViewController (привет Наследование)
class FirstViewController: UIViewController {
    
    // Так как viewDidLoad уже существует у родителя, мы его переопределяем (override)
    // Но код, написанный у родителя, нам тоже нужен. Без него загрузка иерархии вью контроллера осуществиться неправильно
    // Декларируем метод viewDidLoad
    override func viewDidLoad() {
        // Вызываем метод viewDidLoad у родительского класса (в нашем случае это UIViewController)
        // используя слово 'super'
        super.viewDidLoad()
        
        // Вызываем метод print
        print("viewDidLoad in FirstViewController. Тут пишем наш код, например, конвертация валют.")
    }
}

/*
 Если на этом этапе (без кода ниже) запустить плейграунд, то в консоль ничего не выведется, несмотря на то,
 что внутри класса мы какие-то методы вызывали. Потому что самих классов ещё не существует! Мы их не создавали!
 В памяти компьютера ничего нет, код просто написан "на бумаге".
 
 А вто теперь давай всё это дело запустим.
 
 Объявляем константу (слово 'let', можно и 'var' - переменная, в данном примере не принципиально),
 именуем "firstViewController", и это наш "ярлык на рабочем столе" (описывал выше). Сам объект в памяти -
 это наша программа, на которую ссылается ярлык. Повторюсь, это просто ссылка.
 
 В реальном проекте, который мы разбирали, это действие совершит Storyboard. Но тут мы про концепцию.
 */

let firstViewController = FirstViewController()

/*
 А теперь вызовем метод loadView, используя ссылку "firstViewController". В проекте, который мы разбирали, этот
 метод также вызовет Storyboard.
 */

firstViewController.loadView()

/*
 И вот теперь запускай плейграунд.

 То, что вывелось с префиксом "SYSTEM ->" - это то, что должна сделать система, чтобы всё работало.
 Как видишь, код в твоём FirstViewController вызывается после всех системных вызовов.
 
 Развлекайся =)
*/
